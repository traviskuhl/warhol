#!/usr/bin/perl
#
#  warhol - warhol|cdn
# =================================
#  (c) Copyright Travis Kuhl 2011
#  
#
# This is free software. You may redistribute copies of it under the terms of
# the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
# There is NO WARRANTY, to the extent permitted by law.
#

# package as warhol
package Warhol;

# things we need
use POSIX;
use JSON;
use Digest::MD5 qw(md5_hex);
use MIME::Base64;
use Data::Dumper;
use Getopt::Long qw(GetOptionsFromArray :config pass_through permute);
use Cwd qw(abs_path realpath);
use File::Spec::Functions qw(rel2abs abs2rel updir);
use File::Basename;
use File::Temp qw/ tempfile tempdir /;
use File::stat;
use File::Copy;
use File::Path qw/make_path/;
use OAuth::Lite::Consumer;

# version
our $VERSION = "0.1";

# start
our $Warhol = new Warhol();

# some consts
use constant TYPE_CSS => 1;
use constant TYPE_JS => 2;
use constant TYPE_PNG => 3;
use constant TYPE_GIF => 4;
use constant TYPE_JPG => 5;
use constant TYPE_ICO => 6;

# types
use constant TYPES => {
	TYPE_CSS => {"name" => "css", "ext" => ".css", "mime" => "text/css", "group" => "style", "id" => TYPE_CSS, "parseable" => 1},
	TYPE_JS => {"name" => "js", "ext" => ".js", "mime" => "text/javascript", "group" => "javascript", "id" => TYPE_JS, "parseable" => 1},
	TYPE_PNG => {"name" => "png", "ext" => ".png", "mime" => "image/png", "group" => "images", "id" => TYPE_PNG},	
	TYPE_GIF => {"name" => "gif", "ext" => ".gif", "mime" => "image/gif", "group" => "images", "id" => TYPE_GIF},	
	TYPE_JPG => {"name" => "jpg", "ext" => ".jpg", "mime" => "image/jpg", "group" => "images", "id" => TYPE_JPG},		
	TYPE_ICO => {"name" => "ico", "ext" => ".ico", "mime" => "image/ico", "group" => "images", "id" => TYPE_ICO},		
};


##
## @brief create a new instance
##
sub new {

	# get the refrence
	my($ref) = @_;

	# define some stuff
	my $self = {
		
		# holders
		'args' => (),
		'opts' => (),
		
		# temp dir
		'tmp' => tempdir(CLEANUP => 0),
	
		# list of commands
		'cmds' => {
		
			# !help
			"help" => {
				"func" => \&cmd_help,
				"opts" => 0
			},
		
			# !init
			"init" => {
				"func" => \&cmd_init,
				"opts" => ["api=s","key=s","secret=s"]
			},

			# !commit
			"commit" => {
				"func" => \&cmd_commit,
				"opts" => ["push","fresh"]
			},
			
			# !push
			"push" => {
				"func" => \&cmd_push,
				"opts" => ["commit","force"]
			},
			
			# import
			"import" => {
                "func" => &cmd_import,
                "opts" => [""]
			}
			
		}	
		
	};

	# bless and return me
	bless($self);			
	
	# exec
	$self->start();

	# self
 	return $self;

}


##
## @brief start the instance
##
sub start {
	my $self = shift;	
	
	# check arg1 for our command
	my $cmd = shift @ARGV || "help";
	
	# see if the command works
	unless (exists $self->{cmds}->{$cmd}) {
		$cmd = "help";
	}
	
	# args
	my @args = ();
	my @cleaned = ();

	# loop through args and find
	# anything that isn't an opt
	foreach my $a (@ARGV) {
		if (substr($a,0,1) ne '-') {
			push(@args, $a);
		}
		else {
			push(@cleaned, $a);
		}
	}
	
	# vars holder
	my %vars = ();
	my @opts = (\@cleaned, \%vars);
	
	# send to getopts
	GetOptionsFromArray((@opts,@{$self->{cmds}->{$cmd}->{opts}}));
	
	# globalize them
	$self->{args} = \@args;
	$self->{opts} = \%vars;

	# call the func
	$self->{cmds}->{$cmd}->{func}($self);

}

sub opt {my ($self, $name) = @_; return $self->{opts}->{$name} || undef; }
sub arg {my ($self, $idx) = @_; return $self->{args}[$idx] || undef; }


##
## @brief show help message
##
sub cmd_help {
	my $self = shift;

	print "help!"; exit;

}


##
## @brief init the tree for warhol
##
sub cmd_init {
	my $self = shift;

	# ask them for their key and secret
	my $key = $self->opt('key') || _ask("OAuth Key:");
	my $secret = $self->opt('secret') ||  _ask("OAuth Secret:");
	my $project = _ask("Project Name: ");
	my $def = _ask("Default visibility to Public [Y/n]: ", "Y");

		# need all
		unless($key && $secret && $project) {
			_msg("You left out some required information."); exit;
		}

	# our config
	my $config = { 
		'key' => $key,
		'secret' => $secret,
		'visiblity' => (uc(substr($def,0,1)) eq 'Y' ? 'public' : 'private'),
		"api" => "https://".($self->opt("api") || "warholcdn.com")."/"
	};

	# try to valid it
	my $resp = $self->oauth("verify", {}, $config);
	
		# bad response
		unless ($resp) {
			_msg("Could not validate your OAuth information."); exit;
		} 
	
		# already a project
		if ( _in_array(\@{$resp->{projects}}, $project) ) {
			_msg("You already have a project named '$project'."); exit;
		}
	
	# add their username to config
	$config->{username} = $resp->{username};
	$config->{project} = $project;
	
	# root url
	$config->{root} = {
		"http" => "a.warholcdn.com/$resp->{username}/$project/",
		"https" => "$resp->{ssl}/$resp->{username}/$project/" 
	};
	
	# make our dir 
	mkdir("./.warhol");

	# write our config
	_file_put("./.warhol/config", to_json($config));
	
	# done
	_msg(" Initiation Complete!\n Run `warhol push` to publish assets."); exit;
	
}

##
## @brief publish all static files to warhol 
##			cmd is push
##
sub cmd_commit {
	my $self = shift;
	
	# folder
	my $folder = $self->arg(0) || ".";

	# opts
	my $force = $self->opt('force') || 0;

		# message
		_msg("Starting Push for folder '$folder'");

	# figure the config dir
	# and load the config
	my ($root, $config) = _config($folder);

		# found our config file
		_msg(" found configuration at '$root'");	

	# lets commit 
	($manifest) = $self->commit($folder, $root, $config, $force);	

	# completed commit
	_msg(" Commit Complete");

	exit;

}


##
## @brief publish all static files to warhol 
##			cmd is push
##
sub cmd_push {
	my $self = shift;
	
	# folder
	my $folder = $self->arg(0) || ".";

	# opts
	my $commit = $self->opt('commit') || 0;
	my $force = $self->opt('force') || 0;

		# message
		_msg("Starting Push for folder '$folder'");

	# figure the config dir
	# and load the config
	my ($root, $config) = _config($folder);

		# found our config file
		_msg(" found configuration at '$root'");
	
	my $manifest;
	
	# should we commit
	if ($commit) {
		$manifest = $self->commit($folder, $root, $config, $force);
	}
	else {
	
		# check for a manifest
		unless ( -e "$root/.warhol/build.manifest" ){
			_msg(" could not find manifest! Run `warhol commit .` first."); exit;
		}

		unless ( -e "$root/.warhol/build" ){
			_msg(" could not find a commit file! Run `warhol commit .` first."); exit;
		}
	
		# found our config file
		_msg(" found manifest file at '$root'");	
	
		# find the manifest
		$manifest = from_json(_file_get("$root/.warhol/build.manifest"));	

	}
	
	# found our config file
	_msg(" found commit file at '$root'");	
	
	# sending
	_msg(" sending commit file to $config->{api}...");	
	
	# send the to 
	my $resp = $self->oauth("build", {"file"=>encode_base64(_file_get($root.".warhol/build"))}, $config);

	# sending
	_msg(" send done... processing response.");	

	# what happened
	if ($resp) {

		# remove the build file
		unlink($root.".warhol/build");
		unlink($root.".warhol/build.manifest");
	
		# write manifest to the config dir
		_file_put("$root/.warhol/manifest", to_json($manifest));		
	
		# build has been queued
		if ( exists $resp->{queued} && $res->{queued} == 1 ) {
			
			# message
			_msg(("="x80));	
			_msg("Success!!");
			_msg("Build in progress. Reference id: $resp->{ref}");	
			_msg("Builds usually finish in a few seconds. You'll get ");
			_msg("an email when your build is complete and your files are ready");
			_msg(("="x80));	
			
		}
		
		# build is already done and ready to go
		elsif ( exists $resp->{success} && $resp->{success} == 1 ){
		
			# message
			_msg(("="x80));	
			_msg("Success!!");
			_msg("Build in complete and ready to use.");
			_msg("Reference id: $resp->{ref}");	
			_msg(("="x80));			
		
		}	
		
		# build failed
		else {
		
			# message
			_msg(("="x80));	
			_msg("Fail!!");
			_msg("Your build did not complete. Error:");
			_msg("$resp->{error}");	
			_msg(("="x80));			
		
		}				
		
	}
	else {
		_msg("Your build failed. Please visit the site for more information");
	}

}

##
## @brief publish all static files to warhol 
##			cmd is push
##
sub commit {
	my $self = shift;
	my $folder = shift;
	my $root = shift;
	my $config = shift;
	my $force = shift || 0;

	# build number
	my $bid = time();

	# find all assets in the folder
	# and find the tree
	my $assets = _search_dir($folder, ["*.css","*.js","*.png","*.jpg","*.gif","*.ico"]);
	my $tree = _search_dir($root, ["*.css","*.js","*.png","*.jpg","*.gif","*.ico"]);
	
		# how many did we find
		_msg(" found ".scalar(@$assets)." asset files in '$folder'");

	# open the manifest
	my $manifest = from_json( _file_get("$root/.warhol/manifest") || '{"files":{}, "style":{}, "javascript":{}, "images":{}}' );
	
		# if fresh, we can like the manifest doesn't exisst
		if ( $self->opt('fresh') ) {
			$manifest = { "files" => {}, "style" => {}, "javascript" => {}, "images" => {}};
		}
	
	# css
	my @parseable = ();

	# now we know everything is in the manifest
	# lets go through asset files that they want 
	# to update and update the manifest
	foreach my $file (@$assets) {
		
		# parse file
		my ($f) = _parse_file($file, $root);

			# add to build
			_msg("  found $f->{type}->{name} at '$f->{path}'");			
		
		# local
		my $m = $manifest->{files}->{$f->{id}} || {};
		
		# it's already there
		if ( $m->{mtime} != $f->{mtime} || $f->{type}->{parseable}) {	
		
			# add to build
			_msg("   added $f->{type}->{name} file at '$f->{path}' to push. ".($m->{mtime}-$m->{mtime})." sec diff");			
		
			# make the name
			my $name = $f->{name}."-".$bid.$f->{ext};
		
			# m
			$m = {
				'id' => $f->{id},
				'bid' => $bid,
				'name' => $name,
				'path' => $f->{dir} . $name,
				'mtime' => $f->{mtime},
				'type' => $f->{type},
				'visibility' => 'public',
				'static' => {
					'name' => $f->{name}.$f->{ext},
					'path' => $f->{path},
					'dir' => $f->{dir}
				}
			};
			
		}
		
		# reset manifest
		$manifest->{files}->{$f->{id}} = $m;
		
		# push fid into group
		$manifest->{$f->{type}->{group}}->{$f->{id}} = 1; 

		# make sure our dir exists in tmp
		make_path($self->{tmp}.$f->{dir});
			
		# copy the file to the tmp dir
		copy($file, $self->{tmp}.$m->{path});
	
		# is css
		if ( $f->{type}->{parseable} ) {
			push(@parseable, [$m, $f]);
		}
		
	}
	
	# now loop through all files in the
	# assets list and update any css files
	# in the manifest
	foreach my $file (@parseable) {	
		
		# split it
		$m = $file->[0];
		$f = $file->[1];
			
		# message
		_msg("  processing parseable file $f->{path}");			
			
		# parse the css file with the manifest
		my($parsed, $rollups, $errors, $settings) = _parser($f->{full}, $root, $manifest);
	
			# add settings to the file
			$manifest->{files}->{$f->{id}}->{settings} = $settings;
	
			# errors
			if ( $#errors > 0 ) {
				_msg("   found $#errors:");
				map { _msg("    $_"); } @$errors;
			}
			else {
				_msg("    no errors found. updating push file.");
			}	
	
			# add to any rollups
			foreach $rollkey (@$rollups) {
				
				# try to get the weight
				my ($roll, $weight) = split(/\:/, $rollkey);
				
					# if no weight it is -1
					unless($weight) {$weight = 1;}
				
				# create the rollup
				$manifest->{rollups}->{$f->{type}->{group}}->{$roll} = () unless( exists $manifest->{rollups}->{$f->{type}->{group}}->{$roll} );
				
				# add this file
				$manifest->{rollups}->{$f->{type}->{group}}->{$roll}{$m->{id}} = int($weight);
				
			}
	
		# write it
		_file_put($self->{tmp}.$m->{path}, $parsed);
	
	}		
		
	# set our project
	$manifest->{project} = $config->{project};

	# bid 
	$manifest->{bid} = $bid;

	# write manifest to tmp dir
	_file_put("$self->{tmp}/.manifest", to_json($manifest));

	# add our config to our manifest
	$manifest->{config} = $config;
	
	# remove bid
	# delete $manifest->{bid};
	
	# write manifest to the config dir
	_file_put("$root/.warhol/build.manifest", to_json($manifest));	

	# pwd
	$pwd = getcwd();

	# tar file
	my $tf = "$bid.tar.gz";
	
	# move to our tmp dir
	chdir($self->{tmp});

	# write to tmp
	`tar -czf $tf .`;

	# move tmpfile to root
	system("mv $tf ".$root.".warhol/build");
	
	# go back
	chdir($pwd);	
	
	# return
	return $manifest;

}


sub oauth {
	my $self = shift;
	my $ep = shift;
	my $params = shift || {};
	my $config = shift;
	
	# url
	my $url = $config->{api} ."api/v1/". $ep;
	
	# start aouth consumer
	my $consumer = OAuth::Lite::Consumer->new(
		consumer_key       => $config->{key},
		consumer_secret    => $config->{secret},
		site               => $config->{api},
		request_token_path => q{/api/v1/request_token},
		access_token_path  => q{/api/v1/access_token},
		authorize_path     => q{/api/v1/authorize},
	);
	
    my $res = $consumer->request(
        method => 'POST',
        url    => $url,
        token  => OAuth::Lite::Token->new(
			token  => md5_hex($config->{key}.$config->{secret}),
			secret => $config->{secret},
    	),
       	params => $params
    );	


#	print Dumper($res->content); die;	
	
	# what happened
    if ($res->is_success) {
    
    	# json
		my $j = from_json($res->content);
		
		# status
		if ($j->{status} == 1)  {
			return $j->{response};
		}
		else {
			return 0;
		}
		
    }
    else {
    	return 0;
    }

}



## ==============
##  helper funcs
## ==============

sub _slash_trim {
	my $string = shift;
   	$string =~ s/^\///;
    $string =~ s/\/$//;
	return $string;	
}

sub _f { my $folder = shift; $folder = "/"._slash_trim($folder)."/"; return ($folder eq "//" ? "/" : $folder); }

sub _config {

	# folder
	my $folder = rel2abs(shift);

	# is it in this dir
	if (-e "$folder/.warhol/config") {
		return (_f($folder), from_json(_file_get("$folder/.warhol/config")));
	}

	# stop
	my $dir = dirname($folder);

	# recurse until we find a .warhol dir
	while (-d $dir && $dir ne "/") {
		if ( -e $dir."/.warhol/config" ) {
			return (_f($dir), from_json(_file_get("$dir/.warhol/config")));
		}
		else {
			$dir = dirname($dir);
		}
	}

	# no config
	_msg("No configuration file found. Run:");
	_msg("`warhol init` to configure.");
	exit;
	
}

sub _parse_file_settings {
	my $str = shift;

	# settings
	my $settings = {};

	# first line
	while ($str =~ /\@warhol([^\n]+)/gi) {
	
		# match what to do
		foreach $setting (split(/ /, $1)) {
		
			# no = means no settings
			unless ( $setting =~ /\=/ ) { next; }
		
			# split on =
			my ($name, $val) = split(/\=/,$setting);
			
			# add the settings
			$settings->{$name} = $val;
			
		}
				
	}	

	# give back
	return $settings;

}

sub _parser {
	my $file = shift;
	my $root = shift;
	my $manifest = shift;

	# errors
	my @errors = ();
	my @rollups = ();
	
	# parse the file
	my ($name, $rpath) = fileparse($file, ('.css','.js'));	
	
		# no name rturn
		unless($name) { return ($str, \@rollups, \@errors); }

	# css 
	$str = _file_get($file);	
	
	# settings
	my $settings = _parse_file_settings($str);
	
		# set rollup
		@rollups = split(/\,/, $settings->{rollup}) if exists $settings->{rollup};
			
	# loop and fond
	while($str =~ /url\(([^\)]+)\)/gi) {
				
		# does it have a http in it go to next
		if ( substr($1, 0, 4) eq "http" ) { next; }
		
		# oath
		my $path = realpath($rpath.$1);
		
		# has to be a real file
		if ( -e $path ) {
		
			# now lets parse that file
			my ($f) = _parse_file($path, $root);
			
			# find it in manifest
			if ( exists $manifest->{files}->{$f->{id}} ) {
			
				# man ifle
				my $mf = $manifest->{files}->{$f->{id}};
			
				# replace the static name
				my $rep = $found = $1;
				
				# replace the name
				$rep =~ s/$mf->{static}->{name}/$mf->{name}/;			
				
				# replace with the current path
				$str =~ s/$found/$rep/;	
				
			}
			else {
				push(@error, "File '$1' does not exists in manifest");
			}
			
		}

	}
	
	# return 
	return ($str, \@rollups, \@errors, $settings);

}


sub _parse_file {
	my $file = realpath(shift);
	my $root = realpath(shift);
	
	# stat our file
	my $st = stat($file);

	# parse the file
	my ($name, $path, $suff) = fileparse($file, ('.css','.js','.png','.jpg','.gif','.ico'));

	# remove the root
	$path =~ s/$root//;

	# type 
	my %types = (
		'.css'	=> TYPES->{TYPE_CSS},
		'.js'	=> TYPES->{TYPE_JS},
		'.png'	=> TYPES->{TYPE_PNG},
		'.gif'	=> TYPES->{TYPE_GIF},
		'.jpg'	=> TYPES->{TYPE_JPG},
		'.ico'  => TYPES->{TYPE_ICO} 
	);
	
	# type
	my $type = $types{$suff};
	
	# fpath
	my $fpath = _f($path) . $name . $suff;	

	# reutrn
	return ({
		'id' => md5_hex($fpath),
		'name' => $name,
		'dir' => _f($path),
		'path' => $fpath,
		'type' => $type,
		'full' => $file,
		'ext' => $suff,
		'stat' => $st,
		'mtime' => $st->mtime
	});

}

sub _search_dir {

	# dir and glob
	my $dir = shift;
	my $name = shift;
	my @found = ();

	# act
	my $act = "find $dir -type f -and \\( " . join(" -o ",map { "-name '$_'" } @$name)." \\)";

	# glob me
	my @f = map { rel2abs($_); } split(/\n/,`$act`);

	# return 
	return \@f;

}

sub _msg {
	my $msg = shift;
	my $status = shift;	

	print $msg ."\n";
}

sub _ask {

    # whas the question
    my $q = shift;
    my $d = shift;
    my $p = shift;
    
    # ask it
    print $q . " ";
    
    if ( $p ) {
    	`stty -echo`;
    }
    
    # wait for an answer
    my $a = <STDIN>; chomp $a;

    if ( $p ) {
    	`stty echo`; print "\n";
    }
    
    # give it back
    return $a || $d;
    
}

sub _file_get {

	my ($file) = @_;

	open(FH,$file);
	my @f = <FH>;
	close(FH);

	return join("",@f);

}

sub _file_put {

	my ($file,$content) = @_;

	open(FH,">".$file) || fail("Could not write to $file");
	print FH $content;
	close(FH);

}

sub _in_array {
    my ($arr,$search_for) = @_;
    foreach my $value (@$arr) {
        return 1 if $value eq $search_for;
    }
    return 0;
}